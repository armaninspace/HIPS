/*
 * Copyright (c) 1991 The Turing Institute
 *
 * Disclaimer:  No guarantees of performance accompany this software,
 * nor is any responsibility assumed on the part of the authors.  All the
 * software has been tested extensively and every effort has been made to
 * insure its reliability.
 */

/*
 * sinegen.c - to generate a test image containing sinusoids of
 *             varying spatial frequencies and amplitudes.
 *
 * Usage:	sinegen
 *              [-r rows [cols] | -c [cycles]]
 *              [-o octaves [frequency] |
 *               -d decades [frequency] |
 *               -f frequency [levels] [scale]]
 *              [-b decibels [amplitude] |
 *               -a amplitude [levels [scale]]]
 *              [-p phase]
 *              [-w pad_window]
 *              [-F | -D]
 *              > image
 *
 * Description: sinegen generates and output a sinusoid image in
 *              HIPS2 format to standard output. The pixel format
 *              of the generated image will be either float
 *              or double as selected by the "-F" or "-D" options.
 *              By default, a float image is generated.
 *
 *              The images generated by sinegen vary in frequency along
 *              each row, and in amplitude along each column.
 *              
 *              sinegen operates in either ramped mode, enabled by
 *              the "-r" flag or full-cycle mode enabled by the"-c"
 *              flag. In ramped mode, the frequency and amplitude range
 *              are varied continuously across the image rows and cols
 *              (but not within the pad boundary described later). The
 *              of the ramp portion of the generated image is given by
 *              "rows" and "cols". In full-cycle mode, sinegen generates
 *              an image containing an integral number of full cycles
 *              of each frequency and amplitude level. The number of
 *              cycles of each frequency level is given by "cycles".
 *              By default, sinegen generates an image of size 512x512
 *              in ramped mode.
 *
 *              The frequency range in the generated image is given
 *              by the "-o", "-d" or "-f" options which specify
 *              an octave range, a decade range or an arbitrary frequency
 *              range. By default, a frequency range of 2 octaves up to
 *              0.05 cycles/pixel is generated. Note that these options
 *              are mutually exclusive. All frequency values should be
 *              quoted in cycles/pixel.
 *
 *              The amplitude range is given by either the "-b" or "-a"
 *              options which specify an amplitude bandwidth in decibels
 *              or an arbitrary amplitude range respectively. These
 *              options are mutually exclusive. By default, 2 decibels
 *              starting from unity amplitude are present.
 *
 *              sinegen defaults to generating a sine wave image. The
 *              phase of the generated sinusoid can be set using the "-p"
 *              flag, quoting the desired phase in degrees.
 *
 *              A pad boundary may be placed around the sinusoid image to
 *              avoid boundary problems in later processing. The width
 *              of this boundary is given by the "-w" flag and defaults
 *              to 0, ie no pad boundary. In ramped mode, the boundary is
 *              built by replicating the top and bottom amplitude rows,
 *              by continuing the lowest and highest frequency signals
 *              to form the left and right columns respectively. In this
 *              mode, "pad_window" is effectively the size of the
 *              boundary is pixels. In full-cycle mode, "pad_window"
 *              cycles of the lowest and highest frequency signals are
 *              added at the left and right of the image, and
 *              "pad_window" amplitude rows are replicated at the top and
 *              bottom of the image.
 *
 * Load:	cc -o sinegen sinegen.c -lhips -lm
 *
 * Author:	David Wilson - 14/1/92
 *
 */




/*
** Specify include files.
*/

#include <stdio.h>
#include <math.h>
#include <hipl_format.h>




/*
** Specify macro definitions.
*/

#define  FREQ_LIMIT    0.05 		/* Upper frequency limit */
#define  ONE_DB_GAIN   1.1220185	/* Gain equivalent to 1dB */




/*
** Define the command line options accepted by this filter.
*/

static Flag_Format flagfmt[] =
{
    {"r", {"c", LASTFLAG}, 1, {{PTBOOLEAN, "TRUE", "enable"},
                               {PTINT, "-1", "rows"},
			       {PTINT, "-1", "cols"},
			       LASTPARAMETER}},
    {"c", {"r", LASTFLAG}, 0, {{PTBOOLEAN, "FALSE", "enable"},
                               {PTINT, "1", "cycles"},
			       LASTPARAMETER}},
    {"o", {"d", "f",  LASTFLAG}, 0, {{PTBOOLEAN, "TRUE", "enable"},
                                     {PTINT, "2", "octaves"},
			             {PTDOUBLE, "-1.0", "frequency"},
			             LASTPARAMETER}},
    {"d", {"f", "o",  LASTFLAG}, 0, {{PTBOOLEAN, "FALSE", "enable"},
                                     {PTINT, "2", "decades"},
			             {PTDOUBLE, "-1.0", "frequency"},
			             LASTPARAMETER}},
    {"f", {"o", "d", LASTFLAG}, 1, {{PTBOOLEAN, "FALSE", "enable"},
			            {PTDOUBLE, "0.001", "frequency"},
			            {PTINT, "2", "levels"},
			            {PTDOUBLE, "2.0", "scale"},
			            LASTPARAMETER}},
    {"b", {"a", LASTFLAG}, 1, {{PTBOOLEAN, "TRUE", "enable"},
			       {PTINT, "2", "decibels"},
			       {PTDOUBLE, "1.0", "amplitude"},
			       LASTPARAMETER}},
    {"a", {"b", LASTFLAG}, 1, {{PTBOOLEAN, "FALSE", "enable"},
			       {PTDOUBLE, "1.0", "amplitude"},
			       {PTINT, "2", "levels"},
			       {PTDOUBLE, "10.0", "scale"},
			       LASTPARAMETER}},
    {"p", {LASTFLAG}, 1, {{PTDOUBLE, "0.0", "phase"}, LASTPARAMETER}},
    {"w", {LASTFLAG}, 1, {{PTINT, "0", "pad_window"},
			  LASTPARAMETER}},
    {"F", {"D", LASTFLAG}, 0, {{PTBOOLEAN, "TRUE", "enable"},
			       LASTPARAMETER}},
    {"D", {"F", LASTFLAG}, 0, {{PTBOOLEAN, "FALSE", "enable"},
			       LASTPARAMETER}},
    LASTFLAG
};




int main (argc,
      argv)

int  argc;
char **argv;

{

    int            num_rows, num_cols;
    int            ramp_rows, ramp_cols;
    int            level, num_cycles;
    int            num_freqs, num_octaves, num_decades;
    int            num_amps, num_decibels;
    int            pad_window;
    int            output_format;

    double         freq_scale, base_freq;
    double         base_octave, base_decade;
    double         amp_scale, base_amp;
    double         base_decibel;
    double         phase;
    double         freq;
    double         from_freq, to_freq;
    double         from_amp, to_amp;

    h_boolean        ramped, full_cycles;
    h_boolean        freq_range, octave_range, decade_range;
    h_boolean        amp_range, decibel_range;
    h_boolean        float_output, double_output;

    struct header  image_header;


    /*
    ** Save program name for error handler.
    */

    Progname = strsave(*argv);

    /*
    ** Handle command line arguments.
    */

    parseargs (argc,
	       argv,
	       flagfmt,
	       &ramped,
	       &ramp_rows,
	       &ramp_cols,
	       &full_cycles,
	       &num_cycles,
	       &octave_range,
	       &num_octaves,
	       &base_octave,
	       &decade_range,
	       &num_decades,
	       &base_decade,
	       &freq_range,
	       &base_freq,
	       &num_freqs,
	       &freq_scale,
	       &decibel_range,
	       &num_decibels,
	       &base_decibel,
	       &amp_range,
	       &base_amp,
	       &num_amps,
	       &amp_scale,
	       &phase,
	       &pad_window,
	       &float_output,
	       &double_output,
	       FFNONE);

    /*
    ** Determine the frequency range of the sinusoids.
    */

    if (freq_range == TRUE)
    {
        from_freq = base_freq;
	to_freq = base_freq * pow (freq_scale, (double) num_freqs - 1);
    }
    else if (octave_range == TRUE)
    {
	freq_scale = 2.0;
	num_freqs = num_octaves + 1;

	if (base_octave == -1.0)
	{
	    from_freq = FREQ_LIMIT / pow (2.0, (double) num_octaves);
	    to_freq = FREQ_LIMIT;
	}
	else
	{
	    from_freq = base_octave;
	    to_freq = base_octave * pow (2.0, (double) num_octaves);
	}
    }
    else if (decade_range == TRUE)
    {
	freq_scale = 10.0;
	num_freqs = num_decades + 1;

	if (base_decade == -1.0)
	{
	    from_freq = FREQ_LIMIT / pow (10.0, (double) num_decades);
	    to_freq = FREQ_LIMIT;
	}
	else
	{
	    from_freq = base_decade;
	    to_freq = base_decade * pow (10.0, (double) num_decades);
	}
    }

    /*
    ** Determine the amplitude range of the sinusoids.
    */

    if (amp_range == TRUE)
    {
        from_amp = base_amp;
	to_amp = base_amp * pow (amp_scale, (double) num_amps - 1);
    }
    else if (decibel_range == TRUE)
    {
	if (num_decibels > 0)
	{
	    amp_scale = ONE_DB_GAIN;
	}
	else
	{
	    amp_scale = 1 / ONE_DB_GAIN;
	}

	num_amps = num_decibels + 1;

	from_amp = base_decibel;
	to_amp = base_decibel * pow (amp_scale, (double) num_decibels);
    }

    /*
    ** Convert angular values to radians.
    */

    phase /= H_180_PI;		/* degrees -> radians */
    from_freq *= H_2PI;         /* cycles/pixel -> radians/pixel */
    to_freq *= H_2PI;

    /*
    ** Calculate the size of image needed to display the requested
    ** range of sinusoids. If the image is to contain a frequency
    ** ramp, the size will be specified by the user. If the image is
    ** to contain full cycles of each frequency level, the number
    ** of columns is determined by the period of the sinusoid
    ** signals and the number of rows is given by the range of
    ** amplitude levels.
    */

    if (ramped == TRUE)
    {
	if (ramp_rows == -1)
	{
	    num_rows = 512 + (2 * pad_window);   /* Default values. */
	    num_cols = 512 + (2 * pad_window);
	}
	else if (ramp_cols == -1)
	{
	    num_rows = ramp_rows + (2 * pad_window);
	    num_cols = ramp_rows + (2 * pad_window);
	}
	else
	{
	    num_rows = ramp_rows + (2 * pad_window);
	    num_cols = ramp_cols + (2 * pad_window);
	}
    }
    else if (full_cycles == TRUE)
    {
        num_rows = num_amps + (2 * pad_window);

        num_cols = 0;
        freq = from_freq;
        for (level = 0; level < num_freqs; level++)
        {
    	    if (level == 0 ||
		level == num_freqs - 1)
	    {
	        num_cols += (num_cycles + pad_window) * floor (H_2PI / freq);
	    }
	    else
	    {
	        num_cols += num_cycles * floor (H_2PI / freq);
	    }
	    freq *= freq_scale;
        }

    }

    /*
    ** Set up the image header. Note that only a single frame is
    ** generated.
    */

    if (float_output == TRUE)
    {
	output_format = PFFLOAT;
    }
    else if (double_output == TRUE)
    {
	output_format = PFDOUBLE;
    }

    init_header (&image_header,
		 "",
		 "",
		 1,
		 "",
		 num_rows,
		 num_cols,
		 output_format,
		 1,
		 "");

    write_headeru (&image_header, argc, argv);

    alloc_image (&image_header);

    /*
    ** Generate the test image.
    */

    if (ramped == TRUE)
    {
        h_rsinegen (&image_header,
	            from_freq,
	            to_freq,
	            from_amp,
	            to_amp,
	            phase,
		    pad_window);
    }
    else if (full_cycles == TRUE)
    {
        h_csinegen (&image_header,
	            from_freq,
	            num_freqs,
	            freq_scale,
		    num_cycles,
	            from_amp,
	            num_amps,
	            amp_scale,
	            phase,
		    pad_window);
    }

    write_image (&image_header, 1);

    exit (0);

}
