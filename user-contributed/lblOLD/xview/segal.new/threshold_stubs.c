/*
 * threshold_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `threshold.G'.
 */

#include "common.h"
#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/xv_xrect.h>
#include "segal.h"
#include <group.h>

/*
 * Notify callback function for `set_roi'.
 */
void
threshold_pop_threshold_set_roi_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	if (value == 4)
	{
		threshold.roi = R3d_CUBE;
		refresh_histogram();
	}
	
	if (value == 5)
	{
		threshold.roi = R3d_PT_LIST;
		refresh_histogram();
	}
	
	if (value == 3)
	{
		threshold.roi = R3d_WHOLE;
		refresh_histogram();
	}
	
	if (value == 1)
	{
		threshold.roi = R2d_CROP;
		refresh_histogram();
	}
	
	if (value == 2)
	{
		threshold.roi = R2d_PT_LIST;
		refresh_histogram();
	}
	
	if (value == 0)
	{
		threshold.roi = R2d_WHOLE;
		refresh_histogram();
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `set_effect'.
 */
void
threshold_pop_threshold_set_effect_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_max_down'.
 */
void
threshold_pop_threshold_but_max_down_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		if(threshold.max > threshold.min) {
			erase_thresh_bounds();
			threshold.max--;
			draw_thresh_bounds();
		}
		
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_max_up'.
 */
void
threshold_pop_threshold_but_max_up_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		if(threshold.max < 255) {
			erase_thresh_bounds();
			threshold.max++;
			draw_thresh_bounds();
		}
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_min_down'.
 */
void
threshold_pop_threshold_but_min_down_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		if(threshold.min > 0) {
			erase_thresh_bounds();
			threshold.min--;
			draw_thresh_bounds();
		}
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_min_up'.
 */
void
threshold_pop_threshold_but_min_up_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		if(threshold.min < threshold.max) {
			erase_thresh_bounds();
			threshold.min++;
			draw_thresh_bounds();
		}
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_threshold'.
 */
void
threshold_pop_threshold_but_threshold_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_close'.
 */
void
threshold_pop_threshold_but_close_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Threshold_pop_threshold->pop_threshold, FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
	xv_set(Threshold_pop_threshold->pop_threshold, XV_SHOW, FALSE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Event callback function for `canvas'.
 */
Notify_value
threshold_pop_threshold_canvas_event_callback(win, event, arg, type)
	Xv_window	win;
	Event		*event;
	Notify_arg	arg;
	Notify_event_type type;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(xv_get(win, CANVAS_PAINT_CANVAS_WINDOW), XV_KEY_DATA, INSTANCE);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		thresh_event(event);
	}
	
	/* gxv_end_connections */

	return notify_next_event_func(win, (Notify_event) event, arg, type);
}

/*
 * Notify callback function for `but_black_image'.
 */
void
threshold_pop_threshold_but_black_image_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_white_image'.
 */
void
threshold_pop_threshold_but_white_image_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */
	/* gxv_end_connections */

}

/*
 * Notify callback function for `set_plane'.
 */
void
threshold_pop_threshold_set_plane_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	fprintf(stderr, "segal: threshold_pop_threshold_set_plane_notify_callback: value: %u\n", value);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	if (value == 3)
	{
		threshold.plane = BP;
		refresh_histogram();
	}
	
	if (value == 2)
	{
		threshold.plane = GP;
		refresh_histogram();
	}
	
	if (value == 1)
	{
		threshold.plane = RP;
		refresh_histogram();
	}
	
	if (value == 0)
	{
		threshold.plane = VAL_RGB;
		refresh_histogram();
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `set_mask_effect'.
 */
void
threshold_pop_threshold_set_mask_effect_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	fprintf(stderr, "segal: threshold_pop_threshold_set_mask_effect_notify_callback: value: %u\n", value);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	if (value == 1)
	{
		threshold.mask_effect = THRESH_ADD_TO;
	}
	
	if (value == 0)
	{
		threshold.mask_effect = THRESH_OVERWRITE;
	}
	
	if (value == 2)
	{
		threshold.mask_effect = THRESH_REMOVE_FROM;
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_threshold_mask'.
 */
void
threshold_pop_threshold_but_threshold_mask_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		threshold_mask();
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `set_image_effect'.
 */
void
threshold_pop_threshold_set_image_effect_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	fprintf(stderr, "segal: threshold_pop_threshold_set_image_effect_notify_callback: value: %u\n", value);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	if (value == 0)
	{
		threshold.image_effect = -1 * threshold.degree;
	}
	
	if (value == 1)
	{
		threshold.image_effect = threshold.degree;
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_threshold_image'.
 */
void
threshold_pop_threshold_but_threshold_image_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		threshold_image();
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `set_degree'.
 */
void
threshold_pop_threshold_set_degree_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	fprintf(stderr, "segal: threshold_pop_threshold_set_degree_notify_callback: value: %d\n", value);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		threshold.degree = value;
		if(threshold.image_effect < 0)
			threshold.image_effect = -1 * threshold.degree;
		else threshold.image_effect = threshold.degree;
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_histoeq'.
 */
void
threshold_pop_threshold_but_histoeq_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		histoeq();
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_refresh'.
 */
void
threshold_pop_threshold_but_refresh_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		draw_histogram();
		draw_thresh_bounds();
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_stats'.
 */
void
threshold_pop_threshold_but_stats_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	threshold_pop_threshold_objects *ip = (threshold_pop_threshold_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		draw_histo_stats();
	}
	
	/* gxv_end_connections */

}
