/*
 * mask_log_stubs.c - Notify and event callback function stubs.
 * This file was generated by `gxv' from `mask_log.G'.
 */

#include <stdio.h>
#include <sys/param.h>
#include <sys/types.h>
#include <xview/xview.h>
#include <xview/panel.h>
#include <xview/textsw.h>
#include <xview/xv_xrect.h>
#include "segal.h"

#include "common.h"

/*
 * Event callback function for `controls'.
 */
Notify_value
edit_mask_defined(win, event, arg, type)
	Xv_window	win;
	Event		*event;
	Notify_arg	arg;
	Notify_event_type type;
{
	mask_log_pop_mask_log_objects *ip = (mask_log_pop_mask_log_objects *) xv_get(win, XV_KEY_DATA, INSTANCE);
	
	make_edit_mask_defined(event);
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

	return notify_next_event_func(win, (Notify_event) event, arg, type);
}

/*
 * Notify callback function for `set_mask_type'.
 */
void
set_mask_type(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	mask_log_pop_mask_log_objects *ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	set_mask_type_proc(value);

	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_close'.
 */
void
mask_log_pop_mask_log_but_close_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	mask_log_pop_mask_log_objects *ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */
	/* gxv_end_connections */

}

/*
 * Menu handler for `menu_mask (Load ...)'.
 */
Menu_item
mask_log_menu_mask_item0_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	mask_log_pop_mask_log_objects * ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(File_pop_load_mask->pop_load_mask, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_mask (New ...)'.
 */
Menu_item
mask_log_menu_mask_item1_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	mask_log_pop_mask_log_objects * ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		xv_set(File_pop_new_mask->pop_new_mask, XV_SHOW, TRUE, NULL);
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Notify callback function for `but_options'.
 */
void
mask_log_pop_mask_log_but_options_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	mask_log_pop_mask_log_objects *ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Mask_log_pop_options->pop_options, FRAME_CMD_PUSHPIN_IN, TRUE, NULL);
	xv_set(Mask_log_pop_options->pop_options, XV_SHOW, TRUE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_close_mask_log'.
 */
void
mask_log_pop_mask_log_but_close_mask_log_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	mask_log_pop_mask_log_objects *ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Mask_log_pop_mask_log->pop_mask_log, FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
	xv_set(Mask_log_pop_mask_log->pop_mask_log, XV_SHOW, FALSE, NULL);
	
	xv_set(Mask_log_pop_options->pop_options, FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
	xv_set(Mask_log_pop_options->pop_options, XV_SHOW, FALSE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `but_close_options'.
 */
void
mask_log_pop_options_but_close_options_notify_callback(item, event)
	Panel_item	item;
	Event		*event;
{
	mask_log_pop_options_objects *ip = (mask_log_pop_options_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	xv_set(Mask_log_pop_options->pop_options, FRAME_CMD_PUSHPIN_IN, FALSE, NULL);
	xv_set(Mask_log_pop_options->pop_options, XV_SHOW, FALSE, NULL);
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `set_apply_log'.
 */
void
mask_log_pop_options_set_apply_log_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	mask_log_pop_options_objects *ip = (mask_log_pop_options_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	if (value == 1)
	{
		mlog.apply_log = FALSE;
	}
	
	if (value == 0)
	{
		mlog.apply_log = TRUE;
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `set_apply_order'.
 */
void
mask_log_pop_options_set_apply_order_notify_callback(item, value, event)
	Panel_item	item;
	int		value;
	Event		*event;
{
	mask_log_pop_options_objects *ip = (mask_log_pop_options_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	if (value == 0)
	{
		mlog.apply_order = ORDER_EI;
	}
	
	if (value == 1)
	{
		mlog.apply_order = ORDER_IE;
	}
	
	/* gxv_end_connections */

}

/*
 * Notify callback function for `ls_mask_filenames'.
 */
int
mask_log_pop_mask_log_ls_mask_filenames_notify_callback(item, string, client_data, op, event, row)
	Panel_item	item;
	char		*string;
	Xv_opaque	client_data;
	Panel_list_op	op;
	Event		*event;
	int		row;
{
	mask_log_pop_mask_log_objects *ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch(op) {
	case PANEL_LIST_OP_DESELECT:
		break;

	case PANEL_LIST_OP_SELECT:
		break;

	case PANEL_LIST_OP_VALIDATE:
		break;

	case PANEL_LIST_OP_DELETE:
		break;
	}
	
	/* gxv_start_connections DO NOT EDIT THIS SECTION */

	{
		select_mask_in_list(string);
	}
	
	/* gxv_end_connections */

	return XV_OK;
}

/*
 * Menu handler for `menu_mask (Save as ...)'.
 */
Menu_item
mask_log_menu_mask_item3_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	mask_log_pop_mask_log_objects * ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		{
			xv_set(File_pop_save_as->pop_save_as,
				XV_SHOW, TRUE,
				NULL);
			
		}
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_mask (Save)'.
 */
Menu_item
mask_log_menu_mask_item2_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	mask_log_pop_mask_log_objects * ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		{
			save_mask();
		}
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_mask (Unload)'.
 */
Menu_item
mask_log_menu_mask_item4_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	mask_log_pop_mask_log_objects * ip = (mask_log_pop_mask_log_objects *) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_mask_unload (Current selection)'.
 */
Menu_item
mask_log_menu_mask_unload_item0_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	Xv_opaque ip = (Xv_opaque) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		{
			unload_mask(TRUE);
		}
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}

/*
 * Menu handler for `menu_mask_unload (All)'.
 */
Menu_item
mask_log_menu_mask_unload_item1_callback(item, op)
	Menu_item	item;
	Menu_generate	op;
{
	Xv_opaque ip = (Xv_opaque) xv_get(item, XV_KEY_DATA, INSTANCE);
	
	switch (op) {
	case MENU_DISPLAY:
		break;

	case MENU_DISPLAY_DONE:
		break;

	case MENU_NOTIFY:
		
		/* gxv_start_connections DO NOT EDIT THIS SECTION */

		{
			unload_all_masks(TRUE);
		}
		
		/* gxv_end_connections */

		break;

	case MENU_NOTIFY_DONE:
		break;
	}
	return item;
}
